LIST COMPHRENSTION:

List comprehensions are a concise way to create lists in Python. They provide a compact syntax for generating lists based on existing sequences, 
such as lists, tuples, or other iterable objects. This syntax can also include optional conditionals to filter the items included in the resulting list:

[expression for item in iterable]
[expression for item in iterable if condition]

squares = [i**2 for i in range(10)]

Limited to Lists: While list comprehensions are useful for creating lists, they are not applicable for other data structures like dictionaries or sets. 
However, similar comprehensions exist for these data structures as well (e.g., dictionary comprehensions and set comprehensions).
----------------------------

Dictionary comprehensions are similar to list comprehensions, but instead of creating lists, they create dictionaries. 
They provide a concise and readable way to create dictionaries in Python. The general syntax of a dictionary comprehension is:

{key_expression: value_expression for item in iterable}
{key_expression: value_expression for item in iterable if condition}

squared_dict = {i: i**2 for i in range(5)}

This comprehension generates a dictionary by iterating over the numbers from 0 to 4 (range(5)) and creating key-value pairs 
where the key is the number itself (i) and the value is the square of the number (i**2). The resulting dictionary will be {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}.

--------------------
Set comprehensions are similar to dictionary and list comprehensions, but instead of creating dictionaries or lists, they create sets.
They provide a concise and readable way to create sets in Python. The general syntax of a set comprehension is:

{expression for item in iterable}
{expression for item in iterable if condition}

even_squares = {i**2 for i in range(10) if i % 2 == 0}

Sets is more efficient because it ensure that each element is unique. This property makes sets efficient for operations that require checking for membership
or eliminating duplicates. For example, when creating a set from a list, duplicates are automatically removed, resulting in a set containing only unique elements.


GENERATOR EXPRESSIONS:

Generator expressions are concise and memory-efficient constructs in Python for creating iterators. They produce values lazily, one at a time, 
as they are needed, rather than generating all values upfront and storing them in memory. Generator expressions are similar to list comprehensions,
but they use parentheses instead of square brackets.
The syntax of a generator expression is similar to that of a list comprehension:
(expression for item in iterable)
However, unlike list comprehensions, which create lists, generator expressions create generator objects. These generator objects can be
iterated over using a loop or consumed by functions that accept iterables.

Generator expressions produce values on-the-fly as they are needed, rather than generating all values at once.This lazy evaluation saves memory 
and can be more efficient, especially for large datasets or infinite sequences.

Generator expressions create generator objects, which are a type of iterator.
These iterators can be iterated over using a loop, consumed by functions that accept iterables, or converted to other data structures like lists using
the list() constructor.

squares_gen = (i**2 for i in range(10))
print(sqares_gen) //<generator object <genexpr> at 0x00000123456789AB>

If you want to see the values generated by the generator expression, you need to iterate over it or convert it to a list and then print it, 
as shown below.

# Iterate over the generator object and print each square
for square in squares_gen:
    print(square)
(or)
squares_list = list(squares_gen)
print(squares_list)










