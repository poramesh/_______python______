LIST COMPHRENSTION:

List comprehensions are a concise way to create lists in Python. They provide a compact syntax for generating lists based on existing sequences, 
such as lists, tuples, or other iterable objects. This syntax can also include optional conditionals to filter the items included in the resulting list:

[expression for item in iterable]
[expression for item in iterable if condition]

squares = [i**2 for i in range(10)]

Limited to Lists: While list comprehensions are useful for creating lists, they are not applicable for other data structures like dictionaries or sets. 
However, similar comprehensions exist for these data structures as well (e.g., dictionary comprehensions and set comprehensions).
----------------------------

Dictionary comprehensions are similar to list comprehensions, but instead of creating lists, they create dictionaries. 
They provide a concise and readable way to create dictionaries in Python. The general syntax of a dictionary comprehension is:

{key_expression: value_expression for item in iterable}
{key_expression: value_expression for item in iterable if condition}

squared_dict = {i: i**2 for i in range(5)}

This comprehension generates a dictionary by iterating over the numbers from 0 to 4 (range(5)) and creating key-value pairs 
where the key is the number itself (i) and the value is the square of the number (i**2). The resulting dictionary will be {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}.

--------------------
Set comprehensions are similar to dictionary and list comprehensions, but instead of creating dictionaries or lists, they create sets.
They provide a concise and readable way to create sets in Python. The general syntax of a set comprehension is:

{expression for item in iterable}
{expression for item in iterable if condition}

even_squares = {i**2 for i in range(10) if i % 2 == 0}

Sets is more efficient because it ensure that each element is unique. This property makes sets efficient for operations that require checking for membership
or eliminating duplicates. For example, when creating a set from a list, duplicates are automatically removed, resulting in a set containing only unique elements.


GENERATOR EXPRESSIONS:

Generator expressions are concise and memory-efficient constructs in Python for creating iterators. They produce values lazily, one at a time, 
as they are needed, rather than generating all values upfront and storing them in memory. Generator expressions are similar to list comprehensions,
but they use parentheses instead of square brackets.
The syntax of a generator expression is similar to that of a list comprehension:
(expression for item in iterable)
However, unlike list comprehensions, which create lists, generator expressions create generator objects. These generator objects can be
iterated over using a loop or consumed by functions that accept iterables.

Generator expressions produce values on-the-fly as they are needed, rather than generating all values at once.This lazy evaluation saves memory 
and can be more efficient, especially for large datasets or infinite sequences.

Generator expressions create generator objects, which are a type of iterator.
These iterators can be iterated over using a loop, consumed by functions that accept iterables, or converted to other data structures like lists using
the list() constructor.

squares_gen = (i**2 for i in range(10))
print(sqares_gen) //<generator object <genexpr> at 0x00000123456789AB>

If you want to see the values generated by the generator expression, you need to iterate over it or convert it to a list and then print it, 
as shown below.

# Iterate over the generator object and print each square
for square in squares_gen:
    print(square)
(or)
squares_list = list(squares_gen)
print(squares_list)

---------------------------------------------------------------


Iterables
When you create a list, you can read its items one by one. Reading its items one by one is called iteration:

>>> mylist = [1, 2, 3]
>>> for i in mylist:
...    print(i)
1
2
3
mylist is an iterable. When you use a list comprehension, you create a list, and so an iterable:

>>> mylist = [x*x for x in range(3)]
>>> for i in mylist:
...    print(i)
0
1
4
Everything you can use "for... in..." on is an iterable; lists, strings, files...

These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you
want when you have a lot of values.

Generators
Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory,
they generate the values on the fly:

>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator:
...    print(i)
0
1
4
It is just the same except you used () instead of []. BUT, you cannot perform for i in mygenerator a second time since generators can only be used once:
they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.

Yield
yield is a keyword that is used like return, except the function will return a generator.

>>> def create_generator():
...    mylist = range(3)
...    for i in mylist:
...        yield i*i
...
>>> mygenerator = create_generator() # create a generator
>>> print(mygenerator) # mygenerator is an object!
<generator object create_generator at 0xb7555c34>
>>> for i in mygenerator:
...     print(i)
0
1
4
Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.

To master yield, you must understand that when you call the function, the code you have written in the function body does not run. 
The function only returns the generator object, this is a bit tricky.

Then, your code will continue from where it left off each time for uses the generator.

Now the hard part:

The first time the for calls the generator object created from your function, it will run the code in your function from the beginning until it hits yield, 
then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return 
the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting yield. 
That can be because the loop has come to an end, or because you no longer satisfy an "if/else".

When you see a function with yield statements, apply this easy trick to understand what will happen:

Insert a line result = [] at the start of the function.
Replace each yield expr with result.append(expr).
Insert a line return result at the bottom of the function.
Yay - no more yield statements! Read and figure out the code.
Compare the function to the original definition.
link: https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python


The yield statement in Python does have similarities to the return statement in that both are used to send a value back to the caller.
However, there are key differences between yield and return, especially in the context of pytest fixtures. Let's explore these differences 
and how yield is specifically used in pytest.

Similarities and Differences

return
Purpose: The return statement is used to exit a function and optionally pass a value back to the caller.
Behavior: Once a return statement is executed, the function terminates, and the control is passed back to the caller.
Example:

def get_value():
    return 42
value = get_value()  # value is 42

yield
Purpose: The yield statement is used to produce a value to the caller while suspending the function's state. The function can be resumed later, continuing 
from where it left off.
Behavior: When a function containing yield is called, it returns a generator object. The function's code runs up to the yield statement, returning
the yielded value. Subsequent calls to the generator's __next__() method continue execution after the yield.

Example:

def generate_values():
    yield 1
    yield 2
    yield 3

gen = generate_values()
print(next(gen))  # Output: 1
print(next(gen))  # Output: 2
print(next(gen))  # Output: 3









