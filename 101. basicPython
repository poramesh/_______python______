Thw most basic model for (imperative)programming is sometimes called sequence, selection, iteration.

1. Sequence: Performing operations one at a time in a specified order.
2. Selection: Using conditional statements such as if to select which
operations to execute.
3. Iteration: Repeating some operations using loops or recursion.
____________________________
expressions and evaluation:
__________________________
python can do simple arithmetic. 2+2 is a simple arithmatic expression. 
expression get evaluated and produces a value. 
they dont always have to produce numericle value, it can also evalte to boolean value. 
_______________________________
variables, typpes, and state:
______________________________

a variable, is created by aan assignment statement. 
var_name = some_val
The right side of = is an expression that gets evaluated first. Only later does the assignment happen. If the left side of the
assignment is a variable name that already exist, it is overwritten. If it doesn’t already exist, it is created.

Variables are just names. Every name is associated with some piece of
data, called an object.
The name is a string of characters and it is mapped to an object

Every object has a type. The type often determines what you can do
with the variable. The so-called atomic types in Python are integers,
floats, and booleans, but any interesting program will contain variables of
many other types as well. You can inspect the type of a variable using the
type() function. In Python, the word type and class mean the same thing
(most of the time)


x = 5
y = 3.2
z = True
print("x has type", type(x))
print("y has type", type(y))
print("z has type", type(z))
x has type <class ’int’>
y has type <class ’float’>
z has type <class ’bool’>



you should think of an object as having three things: an identity, a type,
and a value. Its identity cannot change. It can be used to see if two objects
are actually the same object with the is keyword. For example, consider
the following code.

x = [1, 2, 3]
y = x 
'''y = x assigns the reference of the list object [1, 2, 3] (which x points to) to the variable y. 
Now both x and y point to the same object in memory'''
z = [1, 2, 3]
print(x is y) #True
print(x is z) #false
print(x == z) #true


An object cannot change its identity. In Python, you also cannot change
the type of an object. You can reassign a variable to point to different
object of a different type, but that’s not the same thing. There are several
functions that may seem to be changing the types of objects, but they are
really just creating a new object from the old.

x = 2
print("x =", x) #x = 2
print("float(x) =", float(x)) #float(x) = 2.0
print("x still has type", type(x)) #x still has type <class ’int’>
print("Overwriting x.") #Overwriting x.
x = float(x)
print("Now, x has type", type(x)) #Now, x has type <class ’float’>


thisworks = float("inf") //postive infiinity
print("float(\’inf\’) has type", type(thisworks)) //float(’inf’) has type <class ’float’>
infinity_plus_one = float(’inf’) + 1 //inf only.
thisworks = float("ioasodsanf") //cannot convert the string to the float. 


collections:

The next five most important types in Python are strings, lists, tuples,
dictionaries, and sets. 
__________
Strings:
__________
Strings are sequences of characters and can be used to store text of all kinds.
you can concatenate strings to create a new string using the plus sign. 
You can also access individual characters using square brackets and an index.
You can often turn other objects into strings.

s = "Hello, "
t = "World."
u = s + t
print(type(u)) #<class 'str'>
print(u) Hello, World
print(u[9]) r
n = str(9876) 
print(n[2])
__________
Lists:
__________
Lists are ordered sequences of objects. The objects do not have to be the
same type. They are indicated by square brackets and the elements of the
list are separated by commas.
You can append an item to the end of a list
L by using the command L.append(newitem). It is possible to index into a
list exactly as we did with strings.

L=[1,2,3,4,5,6]
print(type(L)) #<class ’list’>
L.append(100) #[1,2,3,4,5,6,100]
print("The first item is", L[0]) #1
print("The second item is", L[1]) #2
print("The last item is", L[-1]) #100
print("The second to last item is", L[-2] #6

ou can also overwrite values in a list using regular assignment statements.
L[2] = ’skip’
L[3] = ’a’
L[4] = ’few’
L[-2] = 99
print(L) [1, 2, 'skip', 'a', 'few', 99, 100]
print(*L) #1 2 skip a few 99 100
_____________
Tuples:
__________
Tuples are also ordered sequences of objects, but unlike lists, they are
immutable. You can access the items but you can’t change what items are
in the tuple after you create it. For example, trying to append raises an
exception.

t = (1, 2, "skip a few", 99, 100)
print(type(t)) #<class ’tuple’>
print(t) #(1, 2, ’skip a few’, 99, 100)
print(t[4]) #100

Here’s what happens when you try to append.
t.append(101)
Traceback (most recent call last):
File "mdi8w4v9ms", line 3, in <module>
t.append(101)
AttributeError: ’tuple’ object has no attribute ’append’

Here’s what happens when you try to assign a value to an item.
t[4] = 99.5
Traceback (most recent call last):
File "me1lm8cv3r", line 3, in <module>
t[4] = 99.5
TypeError: ’tuple’ object does not support item assignment

Note that it would be the same for strings.
s = ’ooooooooo’
s[4] = ’x’

Traceback (most recent call last):
File "x12wl1x2nf", line 4, in <module>
s[4] = ’x’
TypeError: ’str’ object does not support item assignment.

you can update the tuple by  converting it the list or creatign a new tuple with the value "orange", and add that tuple:

thistuple = ("apple", "banana", "cherry")
y = ("orange",)
thistuple += y
print(thistuple) #('apple', 'banana', 'cherry', 'orange')

____________________
Dictionaries (dict)
___________________
Dictionaries store key-value pairs. That is, every element of a dictionary
has two parts, a key and a value. If you have the key, you can get the
value. The name comes from the idea that in a real dictionary (book), a
word (the key) allows you to find its definition (the value).

d = dict()
d[5] = ’five’
d[2] = ’two’
d[’pi’] = 3.1 415926
print(d) #{5: ’five’, 2: ’two’, ’pi’: 3.1415926}
print(d[’pi’]) #3.1415926

Keys can be different types, but they must be immutable types such as
atomic types, tuples, or strings. but they must be immutable types such as
atomic types, tuples, or strings. The reason for this requirement is that we
will determine where to store something using the key. If the key changes,
we will look in the wrong place when it’s time to look it up again.

Dictionaries are also known as maps, mappings, or hash tables. We
will go deep into how these are constructed later in the course. A dictionary
doesn’t have a fixed order.
If you assign to a key that’s not in the dictionary, it simply creates a
new item. If you try to access a key that’s not in the dictionary, you will
get a KeyError.
D = {’a’: ’one’, ’b’: ’two’}
D[’c’]
Traceback (most recent call last):
File "ln2yrzw6yb", line 2, in <module>
D[’c’]
KeyError: ’c’

_______________
sets
___________
They are collections of
objects without duplicates. We use curly braces to denote them and commas
to separate elements. a set has no fixed ordering.
Be careful that empty braces indicates an empty dictionary and not
an empty set.
Notice that the duplicates have no effect on the value as its printed.

s = {2,1}
print(type(s))
s.add(3)
s.add(2)
s.add(2)
s.add(2)
print(s)
<class ’set’>
{1, 2, 3}

Be careful, is an empty dictionary. If you want an empty set, you would
write set().
_________________________________________
some common things to do with collections>
____________________________________________

You can find the number of elements in the collection (the length) using
len.
a = "a string"
b = ["my", "second", "favorite", "list"]
c = (1, "tuple")
d = {’a’: ’b’, ’b’: 2, ’c’: False}
e = {1,2,3,4,4,4,4,2,2,2,1}

print(len(a), len(b), len(c), len(d), len(e)) # 8 4 2 3 4
print(e) #{1,2,3,4}

For the sequential types (lists, tuples, and strings), you can slice a subsequence of indices using square brackets and a colon as in the following
examples. 

The range of indices is half open in that the slice will start with
the first index and proceed up to but not including the last index. Negative
indices count backwards from the end.

Important: slicing a sequence creates a new object. That means a big
slice will do a lot of copying. It’s really easy to write inefficient code this
way.

a = "a string"
b = ["my", "second", "favorite", "list"]
c = (1, 2,3,"tuple")
print(a[3:7]) #trin
print(a[1:-2]) #stri
print(b[1:]) #[’second’, ’favorite’, ’list’]
print(c[:2]) #(1, 2)

















